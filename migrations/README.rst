==================
Database Migration
==================

Pepys-import repository uses `Alembic <https://github.com/alembic/alembic>`_ for data migration. Alembic is a database migration tool which is maintained by SQLAlchemy.
It is possible to apply the existing migrations to the users' database via :code:`pepys_admin`.
Don't forget to check your configuration file before running :code:`pepys_import` or :code:`pepys_admin`.

Instructions
------------
| If this is your first time using Alembic, please do the followings:
|
| Alembic reads DB configurations from the repository's config file( :code:`config.py`). Please check your :code:`PEPYS_CONFIG_FILE` environment variable. If it doesn't exist, it means that :code:`default_config.ini` will be used to create a connection.
|
| If you have an existing DB with tables and values, you have two options:
|
| 1. The easiest option is removing your schema (or entire DB for SQLite) completely and creating from the scratch.  You might run ":code:`alembic upgrade head`" which is going to create all DB tables and :code:`alembic_version` table.
|
| It will *stamp* Alembic's head to the latest migration. You might see this migration revision ID in :code:`alembic_version` table.
|
| 2. (**NOT SUGGESTED!**) If you don't want to lose your values in the DB, you might create :code:`alembic_version` table and *stamp* it manually. For doing that, please run the following commands:

Postgres
""""""""

.. code-block:: postgresql

    CREATE TABLE pepys.alembic_version
    (
        version_num VARCHAR(32) NOT NULL,
        CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
    );
    INSERT INTO pepys.alembic_version VALUES ('XXXXXX');

| Please change XXXXX with the latest migration number (revision variable in the most recent script file in :code:`migrations/postgres_versions`).
| If you have the same schema with the base migration script, you won't have any problem. You can test it with this command:

.. code-block:: bash

    alembic current

| If it doesn't throw any error, it is okay to go!

| **Note:** It should print the revision ID of the head with the context information:

.. code-block:: bash

    INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
    INFO  [alembic.runtime.migration] Will assume transactional DDL.
    5154f7db278d (head)

SQLite
"""""""

.. code-block:: sql

    CREATE TABLE alembic_version
    (
        version_num VARCHAR(32) NOT NULL,
        CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
    );
    INSERT INTO alembic_version (version_num)
    VALUES ('XXXXXX');

Please change XXXXX with the latest migration number (revision variable in the most recent script file in :code:`migrations/sqlite_versions`).
So, the last line will stamp your database with the latest migration. For controlling your database version,
you might run the following command:

.. code-block:: bash

    alembic upgrade head

| **Note:** It should print the revision ID of the head with the context information:

.. code-block:: bash

    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    ccc37f794db6 (head)

| If get this output, it means that it worked correctly. You can use Alembic according to your needs.

How to use it? (For Developers)
--------------------------------
You can add/update/delete Base models (:code:`pepys_import.core.store.postgres_db` and :code:`pepys_import.core.store.sqlite_db`).
If there is any change, Alembic might automatically generate a migration script:

.. code-block:: bash

    alembic revision -m "YOUR MESSAGE" --autogenerate

It will create a script under :code:`migrations/postgres_versions` or :code:`migrations/sqlite_versions` according to your configuration.
Alembic assigns revision IDs using :code:`uuid.uuid4()`. When you open the created script, you can see the number (*revision = XXXXXX*)
It is strongly suggested to control the autogenerated script before DB migration.

After the script is checked, you can also interpret SQL script of it.
For doing that the following command might be used:

:code:`alembic upgrade XXXXX --sql > new_migration.sql`. (Please change *XXXX* with the revision ID of the migration script.)

| This command will create a new file named **new_migration.sql** which has SQL Scripts for all migrations, so that you can play with it or run it in your DB's console.
|
| You can also give a start point if you would like to: :code:`alembic upgrade FROM:TO --sql > new_migration.sql`
| For example, there are 2 base migrations for SQLite. If you would like to see the SQL script for the second migration, you can run this command: :code:`alembic upgrade bcf:7df --sql`
| It has to print this script:

.. code-block:: sql

    (pepys-import) baris@bariss-MacBook-Pro pepys-import % alembic upgrade bcf:7df --sql
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Generating static SQL
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade bcff0ccb4fbd -> 7df9dcbd47e7, base2
    -- Running upgrade bcff0ccb4fbd -> 7df9dcbd47e7

    CREATE TABLE "_alembic_tmp_Geometries" (
        geometry_id INTEGER NOT NULL,
        geometry NUMERIC NOT NULL,
        name VARCHAR(150) NOT NULL,
        geo_type_id INTEGER NOT NULL,
        geo_sub_type_id INTEGER NOT NULL,
        start TIMESTAMP,
        "end" TIMESTAMP,
        task_id INTEGER,
        subject_platform_id INTEGER,
        sensor_platform_id INTEGER,
        source_id INTEGER NOT NULL,
        privacy_id INTEGER,
        created_date DATETIME,
        PRIMARY KEY (geometry_id)
    );

    INSERT INTO "_alembic_tmp_Geometries" (geometry_id, geometry, name, geo_type_id, geo_sub_type_id, start, "end", task_id, subject_platform_id, sensor_platform_id, source_id, privacy_id, created_date) SELECT "Geometries".geometry_id, "Geometries".geometry, "Geometries".name, "Geometries".geo_type_id, "Geometries".geo_sub_type_id, "Geometries".start, "Geometries"."end", "Geometries".task_id, "Geometries".subject_platform_id, "Geometries".sensor_platform_id, "Geometries".source_id, "Geometries".privacy_id, "Geometries".created_date
    FROM "Geometries";

    DROP TABLE "Geometries";

    ALTER TABLE "_alembic_tmp_Geometries" RENAME TO "Geometries";

    UPDATE alembic_version SET version_num='7df9dcbd47e7' WHERE alembic_version.version_num = 'bcff0ccb4fbd';

| **Note:** Alembic calls :code:`--sql` flag option as the **offline mode**.
|
| **Note-1:** Please keep in mind that you should consider *possible* failures before applying the migration.
|
| **Note-2:** SQLite doesn't support ALTER TABLE syntax. Therefore, :code:`render_as_batch=True` is passed to the Alembic's context and :code:`batch_alter_table` is used in migration scripts. For further information: `Running Batch Migrations <https://alembic.sqlalchemy.org/en/latest/batch.html>`_
| This batch operation successfully drops a table, creates a new one with an arbitrary name, adds the copied values from the dropped table, and finally renames the new table.
|
| **Note-3:** If you would like to write your own migration script, you don't need to pass :code:`--autogenerate` flag. For example:

.. code-block:: bash

    alembic revision -m "YOUR MESSAGE"

| It will create a migration script with empty :code:`upgrade()`, :code:`downgrade()` functions. You can fill them manually.
|
| When you have new migration scripts to migrate and the scripts are checked/corrected, you can upgrade your DB:

.. code-block:: bash

    alembic upgrade head

----

| It is also possible to downgrade migration scripts. You can give a revision ID to do that:

.. code-block:: bash

    alembic downgrade head REVISION_ID

| If you would like to use relative identifiers, such as :code:`alembic downgrade -1`, you might check it out: `Relative Identifiers <https://alembic.sqlalchemy.org/en/latest/tutorial.html#relative-migration-identifiers>`_
|
| **Note-4:** During the migration of SQLite Database, it's possible to see this error:

.. code-block:: bash

    AddGeometryColumn() error: "UNIQUE constraint failed: geometry_columns.f_table_name, geometry_columns.f_geometry_column"

You can ignore this error because it says that there is already a geometry column entity for your table that has a Geometry column (i.e. States, Geometries, Contact). This error happens because SQLite doesn't support *ALTER TABLE* statement.
Instead, it creates a new one, copies values from the previous table, and drops the existing table. However, during the creation of a new table, it tries to push the Geometry column to the :code:`geometry_columns` table again.

| **Note-5:** If you change a column's name, you should implement different classes for :code:`upgrade()` and :code:`downgrade()` methods. Otherwise, this class breaks your upgrade because it doesn't have that column to rename.
|
| An example can be found in :code:`migrations/sqlite_versions/2020-06-03_f103f27c4575_change_pennant_to_identifier_and_make_.py`. What you should do is as follows:

- :code:`copy_from` post-hook will create all necessary tables. Copy the table that has a column change to :code:`upgrade()` and :code:`downgrade()` methods.
- Remove the global class in the migration script.
- Change the changed column name with the first argument in :code:`alter_column`.

| **Note-6:** :code:`copy_from` post-hook runs for each migration script and therefore, it import many classes, methods that are not necessary for your specific migration script.
| You can detect these unused imports using :code:`flake8` command and remove them.

How to use it? (For Users)
---------------------------
Migrations might be applied in :code:`pepys_admin`. Its migration option migrates the DB to the latest version.
However, if they would like to check it, after ensuring their **config file** points to the correct database, they might run this command to upgrade their DB if there are any migrations:

.. code-block:: bash

    alembic upgrade head

Helpful Commands
----------------
If you would like to see the current head of Alembic: :code:`alembic current`

If you would like to see the history of the migration: :code:`alembic history`

If you have changed schema and want to create a migration script: :code:`alembic revision -m "YOUR MESSAGE" --autogenerate`

If you would like to see SQL script of migration scripts (Don't forget to change *START* and *END* values with the migration revision IDs):
:code:`alembic upgrade START:END --sql`

| If you would like to get information about a migration script of Alembic:
| :code:`alembic -c alembic_sqlite.ini show XXXX` or :code:`alembic -c alembic_postgres.ini show XXXX`
| Please change *XXXX* with a migration script's revision ID or *head* or *current*.
|
| If you would like to edit a migration script:
| :code:`alembic -c alembic_sqlite.ini edit XXXX` or :code:`alembic -c alembic_postgres.ini edit XXXX`
| Please change *XXXX* with a migration script's revision ID or *head* or *current*.

**Note:** Show and Edit commands don't run :code:`env.py` file and it checks the migration scripts in the :code:`version_locations` which is not specified in the main config file.
Therefore, one of the extra config files should be passed to show/edit scripts in :code:`migrations/postgres_versions` and :code:`migrations/sqlite_versions`.

Please check the `cookbook <https://alembic.sqlalchemy.org/en/latest/cookbook.html>`_ and
`documentation <https://alembic.sqlalchemy.org/en/latest/index.html>`_ of Alembic for further information.

Possible Errors and Solutions
-----------------------------

.. code-block:: bash

    sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) Cannot add a NOT NULL column with default value NULL

If you have values in your DB and you try to add a new attribute to the filled table which can't be NULL,
you should make this attribute nullable.

------------

.. code-block:: bash

    File "migrations/env.py", line 9, in <module>
    from config import DB_HOST, DB_NAME, DB_PASSWORD, DB_PORT, DB_TYPE, DB_USERNAME
    ModuleNotFoundError: No module named 'config'

If you face this error, it means that the :code:`pepys-import` repository should be installed in a development environment. Please run the following command when you are **at the root of the repository**:

.. code-block:: bash

    source PATH/TO/YOUR/ENV/bin/activate
    pip install -e .

| The error should be corrected now. Please try to run the same command again.
| Alternatively, you can always add the local project to your :code:`PYTHONPATH`. For example:

.. code-block:: bash

    PYTHONPATH=. alembic current

------------

.. code-block:: bash

    (pepys-import) baris@bariss-MacBook-Pro pepys-import % alembic revision -m "message" --autogenerate
    Database tables are not found! (Hint: Did you initialise the DataStore?)
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    ERROR [alembic.util.messaging] Target database is not up to date.
      FAILED: Target database is not up to date.

If you make some changes and try to create a new migration script without having the latest version of the database, you will face this issue.
You should upgrade your DB and then run the revision command:

.. code-block:: bash

    alembic upgrade head
    alembic revision -m "your message" --autogenerate

------------

**FOR DEVELOPERS ONLY**

.. code-block:: bash

    Database tables are not found! (Hint: Did you initialise the DataStore?)

If you migrated your **SQLite** database and started to see this message, it might mean that your migration script it wrong.
It would have been because of the extra tables created by Alembic. When a table with Geometry column is included in migration,
please check the SQLite database if there are any temporary tables (with *tmp* keyword) such as :code:`idx_Geometries_tmp_geometry_node` etc. If there is any, please drop these tables. After that,
please open your migration script and add :code:`spatial_index=False` argument to the Geometry column. An example is as follows:

.. code-block:: python

    # Change this column
    geometry = deferred(Column(Geometry(geometry_type="GEOMETRY", management=True), nullable=False))
    # Add spatial_index=False parameter
    geometry = deferred(
        Column(
            Geometry(geometry_type="GEOMETRY", management=True, spatial_index=False), nullable=False
        )
    )

------------

.. code-block:: bash

    ValueError: No such constraint: 'XXXX'

This error might happen in both **PostgreSQL** and **SQLite** databases. However, when it happens in **SQLite**,
it might mean that your class that passed in :code:`copy_from` parameter to :code:`batch_alter_table` doesn't have the necessary constraint.
If this error happened for a Check Constraint, it might mean that it's defined in column and it's not detected by Alembic. If that's the case, copy the constraint inside of the column.
If not, you might compare the related class in :code:`pepys_import.core.store.sqlite_db` with the class in the migration script to find out the missing constraint.
Then, you might add the constraint to the class using :code:`Table.append_constraint()` method:

.. code-block:: python

    ...
    # Append constraint
    Sensor.__table__.append_constraint(CheckConstraint("name <> ''", name="ck_Sensors_name"))
    with op.batch_alter_table("Sensors", schema=None, copy_from=Sensor.__table__) as batch_op:
        batch_op.drop_constraint("ck_Sensors_name", type_="check")
    ...

If you face this error during the upgrade, please add :code:`append_constraint()` line inside of the :code:`upgrade()` function.
If you face it during the downgrade, add the line inside of the :code:`downgrade()` function. This error should be corrected now.

------------

Sometimes, it might be necessary to use a new field type of SQLAlchemy, or a new class from the project (i.e. :code:`ReferenceRepr`).
If these new imports break the migration script for :code:`SQLite`, you can add them to the :code:`text` variable in :code:`migrations/env.py`'s :code:`copy_from()` function.
Please add the missing import(s) to the generated migration script manually. But, they will be included next time when you generate a migration script for :code:`SQLite`.

------------

**Why do we have many SQLite related problems ?**


We’re using `render_as_batch=True` parameter to apply the move-and-copy approach for SQLite. Alembic calls it the **_Batch mode_** and I think many of our problems related to that.

`Move-and-copy approach <https://alembic.sqlalchemy.org/en/latest/batch.html#running-batch-migrations-for-sqlite-and-other-databases>`_

::

    Migration tools are instead expected to produce copies of SQLite tables that correspond to the new structure, transfer the data from the existing table to the new one,
    then drop the old table. For our purposes here we’ll call this “move and copy” workflow, and in order to accommodate it in a way that is reasonably predictable,
    while also remaining compatible with other databases, Alembic provides the batch operations context.

For running `--sql` command (in the offline mode), batch-mode asks for `copy_from` parameter. It is explained in `here <https://alembic.sqlalchemy.org/en/latest/batch.html#working-in-offline-mode>`_

::

    In the preceding sections, we've seen how much of an emphasis the "move and copy" process has on using reflection in order to know the structure of the table that is to be copied.
    This means that in the typical case, "online" mode, where a live database connection is present so that Operations.batch_alter_table() can reflect the table from the database,
    is required; the --sql flag cannot be used without extra steps.

    To support offline mode, the system must work without table reflection present, which means the full table as it intends to be created must be passed to Operations.batch_alter_table() using copy_from:

Alembic says that SQLAlchemy doesn’t reflect CHECK Constraints for now and therefore they should be `explicitly defined <https://alembic.sqlalchemy.org/en/latest/batch.html#including-check-constraints>`_

::

    SQLAlchemy currently doesn't reflect CHECK constraints on any backend. So again these must be stated explicitly if they are to be included in the recreated table:

    Note this only includes CHECK constraints that are explicitly stated as part of the table definition, not the CHECK constraints that are generated by datatypes such as Boolean or Enum.

It is said that SQLAlchemy doesn’t reflect it **on any backend**. But it’s strange that it works for PostgreSQL and it works when we pass :code:`copy_from` argument with :code:`__table_args__`  tuple that includes the constraints.

In general, SQLite’s unsupporting `ALTER TABLE`  statement pushes us to use the move-and-copy approach to not lose any data. But when we use it, all problems arise.
